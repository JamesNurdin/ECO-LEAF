% REMEMBER: You must not plagiarise anything in your report. Be extremely careful.

\documentclass{l4proj}

    
%
% put any additional packages here
%

\begin{document}

%==============================================================================
%% METADATA
\title{Carbon Emissions Estimation in Edge Cloud Computing Simulations}
\author{James A. Nurdin}
\date{September 19, 2023}

\maketitle

%==============================================================================
%% ABSTRACT
\begin{abstract}
    Every abstract follows a similar pattern. Motivate; set aims; describe work; explain results.
    \vskip 0.5em
    ``XYZ is bad. This project investigated ABC to determine if it was better. 
    ABC used XXX and YYY to implement ZZZ. This is particularly interesting as XXX and YYY have
    never been used together. It was found that
    ABC was 20\% better than XYZ, though it caused rabies in half of subjects.''

    Include index terms?
\end{abstract}

%==============================================================================

% EDUCATION REUSE CONSENT FORM
% If you consent to your project being shown to future students for educational purposes
% then insert your name and the date below to  sign the education use form that appears in the front of the document. 
% You must explicitly give consent if you wish to do so.
% If you sign, your project may be included in the Hall of Fame if it scores particularly highly.
%
% Please note that you are under no obligation to sign 
% this declaration, but doing so would help future students.
%
%\def\consentname {My Name} % your full name
%\def\consentdate {20 March 2018} % the date you agree
%
\educationalconsent


%==============================================================================
\tableofcontents

%==============================================================================
%% Notes on formatting
%==============================================================================
% The first page, abstract and table of contents are numbered using Roman numerals and are not
% included in the page count. 
%
% From now on pages are numbered
% using Arabic numerals. Therefore, immediately after the first call to \chapter we need the call
% \pagenumbering{arabic} and this should be called once only in the document. 
%
% Do not alter the bibliography style.
%
% The first Chapter should then be on page 1. You are allowed 40 pages for a 40 credit project and 30 pages for a 
% 20 credit report. This includes everything numbered in Arabic numerals (excluding front matter) up
% to but excluding the appendices and bibliography.
%
% You must not alter text size (it is currently 10pt) or alter margins or spacing.
%
%
%==================================================================================================================================
%
% IMPORTANT
% The chapter headings here are **suggestions**. You don't have to follow this model if
% it doesn't fit your project. Every project should have an introduction and conclusion,
% however. 
%
%==================================================================================================================================
\chapter{Introduction}

% reset page numbering. Don't remove this!
\pagenumbering{arabic} 


Why should the reader care about what are you doing and what are you actually doing?
\section{Guidance}

\textbf{Motivate} first, then state the general problem clearly. 

\section{Writing guidance}
\subsection{Who is the reader?}


This is the key question for any writing. Your reader:
\begin{itemize}
    \item
    is a trained computer scientist: \emph{don't explain basics}.
    \item
    has limited time: \emph{keep on topic}.
    \item
    has no idea why anyone would want to do this: \emph{motivate clearly}
    \item
    might not know \emph{anything} about your project in particular:
    \emph{explain your project}.
    \item
    but might know precise details and check them: \emph{be precise and
    strive for accuracy.}
    \item
    doesn't know or care about you: \emph{personal discussions are
    irrelevant}.
\end{itemize}

Remember, you will be marked by your supervisor and one or more members
of staff. You might also have your project read by a prize-awarding
committee or possibly a future employer. Bear that in mind.

\subsection{References and style guides}
There are many style guides on good English writing. You don't need to
read these, but they will improve how you write.

\begin{itemize}
    \item
    \emph{How to write a great research paper}~\cite{Pey17} (\textbf{recommended}, even though you aren't writing a research paper)
    \item
    \emph{How to Write with Style} \cite{Von80}. Short and easy to read. Available online.
    \item
    \emph{Style: The Basics of Clarity and Grace} \cite{Wil09} A very popular modern English style guide.
    \item
    \emph{Politics and the English Language} \cite{Orw68}  A famous essay on effective, clear writing in English.
    \item
    \emph{The Elements of Style} \cite{StrWhi07} Outdated, and American, but a classic.
    \item
    \emph{The Sense of Style} \cite{Pin15} Excellent, though quite in-depth.
\end{itemize}

\subsubsection{Citation styles}

\begin{itemize}
\item If you are referring to a reference as a noun, then cite it as: ``\citet{Orw68} discusses the role of language in political thought.''
\item If you are referring implicitly to references, use: ``There are many good books on writing \citep{Orw68, Wil09, Pin15}.''
\end{itemize}

There is a complete guide on good citation practice by Peter Coxhead available here: \url{http://www.cs.bham.ac.uk/~pxc/refs/index.html}. 
If you are unsure about how to cite online sources, please see this guide: \url{https://student.unsw.edu.au/how-do-i-cite-electronic-sources}.

\subsection{Plagiarism warning}

\begin{highlight_title}{WARNING}
    
    If you include material from other sources without full and correct attribution, you are commiting plagiarism. The penalties for plagiarism are severe.
    Quote any included text and cite it correctly. Cite all images, figures, etc. clearly in the caption of the figure.
\end{highlight_title}


%==================================================================================================================================
\chapter{Background}
What did other people do, and how is it relevant to what you want to do?
\section{Guidance}
\begin{itemize}    
    \item
      Don't give a laundry list of references.
    \item
      Tie everything you say to your problem.
    \item
      Present an argument.
    \item Think critically; weigh up the contribution of the background and put it in context.    
    \item
      \textbf{Don't write a tutorial}; provide background and cite
      references for further information.
\end{itemize}

%==================================================================================================================================
\chapter{Analysis/Requirements}\label{ch:analysis/requirements}
The goal of this project is to extend the open-source edge/cloud computing simulator LEAF with
features to configure particular energy sources (with potentially fluctuating availability and variable carbon intensities),
functionality to translate estimates of power consumption of distributed applications and infrastructure components into carbon footprints â€“ would need to to translate energy consumption into greenhouse gas emissions- helpful to
interesting example scenarios that demonstrate the newly added capabilities.
An interesting demonstration could, for example, test mechanisms for distributed software systems that aim to make the most of low-carbon energy over time and locations.

What is the problem that you want to solve, and how did you arrive at it?
\section{Guidance}
Make it clear how you derived the constrained form of your problem via a clear and logical process. 

In order to approach translating estimations in power consumptions into carbon footprints, Extended Leaf needs to
Using the definition provided by \cite{owid-electricity-mix}, we can define carbon intensity as ``the amount of CO2 that is produced per unit of electricity''.
% INTRODUCE NOTATION FOR CARBON INTENSITY Ci
\section{Configuring Energy Sources}
\section{Translating Power Consumption into Carbon Footprints}
mention notation for carbon intensity
mention issues with converting to discrete event space and timings i.e. assume power drawn for delta t is consistent
\section{Demonstrating Scenarios}

goal Attach power to entitites to the infrastructure
from this need a means to go from power consumed to a carbon footprint
introduce a means to show results to the user

- then allow for interactions
%==================================================================================================================================
\chapter{Design}\label{ch:design}

In this section, the overall design of Extended LEAF is discussed and how the purposes of individual components work together to produce the final product.
%How is this problem to be approached, without reference to specific implementation details?

%Design should cover the abstract design in such a way that someone else might be able to do what you did, but with a different language or library or tool.

\section{Archtecture Overview}\label{sec:architecture-overview}
% overview
Fundamentally Extended LEAF approaches the issues identified in Chapter \ref{ch:analysis/requirements} through a structured approach, dividing the logic of the simulation into three layers: Application, Infrastructure, and Power.
Each layer in the model is designed to carry out a necessary role in the simulation.
As illustrated in Figure \ref{fig:generic-overview}, these layers are utilised by the user in order to carry out a simulation.
For instance, a single application is ran over a section of infrastructure, whilst power is supplied to entities from various power sources.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.65\textwidth]{images/generic-overview.pdf}
    ~
    \caption{Diagram depicting a theoretical simulation and how the layers would be utilised. NB, power connections to infrastructure links have been excluded for illustrative purposes.}
    \label{fig:generic-overview}
\end{figure}

Extended LEAF sees to provide the user with the options necessary to configure simulations according to their requirements.
This is essential as, the simulation model considers many different aspects needed in order to arrive at both an estimation for power consumption and carbon footprint.
As a result of this, it is important to consider how the layers in the framework function and how the model allows for interactions between them to occur.

\section{LEAF}\label{sec:LEAF}
As Extended LEAF sees to continue upon the work written in the paper published by \cite{leaf2021}, the original model already defines the Infrastructure and Application Layers.
However as both layers play an essential role in generating power measurements and carbon emissions, with the infrastructure layer being particularly important, it is also necessary to briefly discuss the intentions of these layers before focusing on what Extended LEAF sees to introduce.

\subsection{Applications}\label{subsec:applications}
At the top of the architecture we have the Application layer, applications $\mathbf{(A)}$ are represented in the model as directed acyclic graphs \citep{leaf2021}, which describe the flow of data F between tasks T of the graph.
Applications are considered as streaming applications as the simulation treats data travelling between tasks to be a continuous process as the simulation moves forward in time.
An application begins at source tasks where data is generated and travels between processing tasks through dataflows before reaching sink tasks.
Finally applications interact with the overall model by being placed on top of entities within the Infrastructure Layer.

\subsection{Infrastructure}\label{subsec:infrastructure}
The Infrastructure $\mathbf{(I)}$ of the model describes the physical entities $\mathbf{(e)}$ of the simulation, in particular these consist of Nodes $\mathbf{(N)}$ and Links $\mathbf{(L)}$ respectively.
The Infrastructure of the model is represented as a weighted directed multigraph \citep{leaf2021}, which specifies how nodes and links inter-connect between each other.
A node in the infrastructure describes physical hardware on which tasks are placed on, nodes are able to be configured in a manner to represent a variety of computing hardware required by the user.
A link describes the means in which nodes within the infrastructure can communicate, because of this dataflows are placed on these entities to describe the potential network requirements in transferring data between tasks.
To simplify the process of modeling complex network systems between nodes in the infrastructure, LEAF allows for large networking systems to be described as a single link.

\subsection{Power Model}\label{subsec:power-model}
As Extended LEAF considers the power consumption of various entities within the infrastructure layer, it is important to consider how power is represented and consumed in the model.
As discussed in the LEAF paper \cite{leaf2021}, every node and link in the infrastructure is assigned a power model.
These are used to model how much power is required by the entity at any given moment in time based on the current state of the entity.
Power for an entity at any given moment in time is considered to be the sum of their static $\mathbf{P_{static}}$ and dynamic $\mathbf{P_{dynamic}}$ power requirements where:
\begin{itemize}
    \item $\mathbf{P_{static}}$ is the idle power requirement.\\
    \item $\mathbf{P_{dynamic}}$ is defined as $\mathbf{C(t) \times \sigma}$, which describes the current load of the node at time $\mathbf{t}$ multiplied by the energy consumed per unit load \citep{leaf2021}.
\end{itemize}

\section{Power Domains}\label{sec:power-domains}
The main goal of the power domain is to allow for configurations and manage how entities in the infrastructure layer should be distributed amongst power sources.
Conceptually, the power domain in a real life scenario can be considered to be a power management system such as etap \citep{etap}.
Power domains should be defined in order to separate the different power options available to a simulation's infrastructure.
For instance when considering power distribution policies for different parts of the infrastructure, individual power domains should be present in order to handle how power sources are allocated, as large scenarios may mean that power sources are present to only part of the infrastructure, see Figure \ref{fig:seperatePDs}.
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{images/seperatePDDiagram.pdf}
    ~
    \caption{Diagram depicting separate power sources available to parts of the infrastructure.}
    \label{fig:seperatePDs}
\end{figure}

Whilst the framework can carry out simulations without including the new additions of Extended LEAF, if the user wants to provide power sources to the infrastructure, then a power domain must be present to allow for interactions to occur and results to be logged.

\subsection{Workflow}\label{subsec:power-domain-workflow}
In order to ensure that power can be correctly distributed to entities in the infrastructure, the power domain consistently adheres to a predefined workflow as the simulation moves forward in time.
By utilising a discrete event space, Extended LEAF can ensure that the workflow can be completed before the simulation takes a step forward in time.
Therefore, the tasks of the power domain are executed in the following order:
\begin{enumerate}
    \item Execute any defined events allocated by the user \emph{(see section \ref{sec:events}}).
    \item Determine the power produced by each power source.
    \item Determine the carbon intensity of each power source.
    \item Order the power sources based on initial user preference.
    \item Allocate entities in the infrastructure to the power sources.
    \item Calculate the carbon released during the time step.
    \item Log results.
\end{enumerate}

\subsection{Distributing Entities}\label{subsec:distributing-entities}
As described in the workflow, a power domain funnels their entities within the infrastructure into particular power sources.
When a power source is considering entities to allocate power to at time $\mathbf{t}$, the default distribution method separates nodes into three categories:
\begin{enumerate}
    \item Entities that were previously provided power by the power source.
    \item Entities that currently have no power source.
    \item Entities that reside in a less desirable power source.
\end{enumerate}

The distribution method considers a power domain's infrastructure entities $\mathbf{I_{pd}}$ in this order to ensure that nodes and links which have an existing association remain powered before the power source allocates any remaining power to other entities.
Despite this, when an entity $\mathbf{e_{i} \in I_{pd}}$ is being considered at the appropriate time, the entity will only be allowed to join if its power requirements are able to be met.
However, whilst the provided approach always preferences existing entities first to ensure consistency and fairness, the model also allows for users to define their own distribution methods to allow for other attributes of the simulation's state to be deciding factors.
For example \ref{sec:eval-example3} demonstrates the ability to dynamically assign infrastructure with uncapped power consumption to power sources with unlimited power available to them.\\

In addition to this, the power domain also considers the order in which power sources are allocated entities.
As one of the goals of the project is to introduce carbon awareness into the simulation, similar to other systems \cite{cucumber}, the power domain utilises a priority queue to order when power sources receive entities.
This has been done to ensure that the user can specify which power sources are allocated entities first, for instance the examples demonstrated in chapter \ref{chp:evaluation} prioritise power sources that have a small inherent carbon intensities to optimise utilisation of cleaner energy.
This will ensure that power sources with a higher carbon intensity at any moment in time, always choose from the smallest set of entities.
This can is formulated as $\mathbf{I_{pd}^j(t) \in I_{r}(t)}$ where:
\begin{itemize}
    \item $\mathbf{I_{pd}^j(t)}$ is the set of infrastructure entities associated to power domain $\mathbf{j}$ at time $\mathbf{t}$.\\
    \item $\mathbf{I_{r}(t)}$ is defined as $\mathbf{I \setminus \left( \bigcup_{j-1} I_{pd}^{j-1}(t) \right)}$, which describes the entities that are yet to be allocated a power source.
\end{itemize}

\subsection{Calculating Carbon Emissions}\label{subsec:carbon-released}
Another role the power domain takes on is generating estimations for how much carbon was released during the step in time for entities within the infrastructure.
In order to achieve this, the power domain inspects the infrastructure present at time $t$ within a given power source ($\mathbf{I_{ps}(t)}$) and individually measures the power for each entity.
As carbon intensity is defined as the amount of carbon released per kilowatt-hour of energy \citep{owid-electricity-mix}, the power measurement is converted into a discrete amount of energy consumed within the timestep.
This can be described as $\mathbf{Energy_{i}} = \mathbf{Power_{i}} \times \mathbf{10^{-3}} \times \mathbf{\varDelta T}$, where:
\begin{itemize}
    \item $\mathbf{Energy_{i}}$ is the amount of energy consumed in watt-hours.
    \item $\mathbf{Power_{i}}$ is the power measurement of entity i in watts.
    \item $\mathbf{\varDelta T}$ is the step in time in hours.
    \item $\mathbf{10^{-3}}$ is used to change to the kilo prefix.
\end{itemize}
From this, the power domain can calculate the carbon emitted by finding the product of this and the carbon intensity of the source through $\mathbf{Carbon Released = Energy_{i} \times CI_{ps(t)}}$.

\subsection{Recording Measurements}\label{subsec:power-domain-recording-measurements}
The final responsibility of the power domain is to record measurements generated during the simulation.
Once an entity within the infrastructure has had their carbon emission calculated, the power domain gathers information about the current state of the entity and composes an entry log.
In particular the following information about the entity's state is logged:
\begin{itemize}
    \item The current time step.
    \item The associated power source.
    \item The energy consumed (in watt-hours).
    \item The carbon emitted.
\end{itemize}

The power domain then proceeds to store this entry so it can be used later on.
As Extended LEAF allows for power consumption outside the power domain's workflow, the framework also provides a means to allow for these actions to be logged, ensuring that the file results of a simulation reflect the events that occurred.

\section{Power Sources}
The responsibility of a power source in Extended LEAF is to provide power to entities in the infrastructure they are associated to.
The model classifies power sources as one of three types:
\begin{enumerate}
    \item Renewable
    \item Mixed
    \item Battery
\end{enumerate}
Where each type is characterised based on their real life counter-parts.
As power sources are used to describe the means of providing power to entities within the infrastructure (for instance onsite solar panels, a rechargeable battery for a mobile device, or even an external power grid), Extended LEAF only considers carbon emissions from the power utilised from these sources by entities and not the supplies themselves.
This is because the goal of the project is to estimate carbon emissions for executing applications on the infrastructure and not for generating power in general.
As a consequence of this, the amount of carbon dioxide emitted because of an entity will be proportional to the power it consumed in the time step.
This amount of carbon, relates to the process in how their power source generated their power.
For instance, carbon intensive processes such as the burning of fossil fuels, produce significantly more carbon compared to those that have no such byproduct.
In addition to this, the model also considers the life cycle assessment of these sources and the carbon released during the manufacturing of these technologies as discussed by \cite{PEHNT200655}.\\

As power sources are able to be distributed amongst infrastructure present in the power domain, it is assumed contextually that when an association occurs, a direct and appropriate power line is utilised from the power source to the device.
Conceptualising this in a real life scenario, we would see that for every power source and entity pairing present in the power domain, a medium to carry the power (for instance a cable) would need to exist.
However, for the simulation model, Extended LEAF assumes that the rate of power transmission is instantaneous, as the latency in the transmission of electricity is negligible \citep{speed-of-electricity} and therefore is not required in the model.
As Extended LEAF operates in discrete periods of time ($\varDelta T$) power in reality, once measured by the model, is considered as energy consumed.
\textit{However for the sake of readability the two terms are used interchangeably throughout the dissertation}.\\

While Section \ref{subsec:distributing-entities} discusses the idea that entities can be distributed amongst power sources, power sources can also retain a static relationship with entities in the infrastructure.
For instance Figure \ref{fig:staticPower} shows how entities in a power domain are distributed over time, in particular the entities allocated to the national grid power supply have been permanently allocated and we can see as time moves forward in the simulation the entities remain locked to that power source.
This feature has been designed to particularly address the scenario identified in \ref{DOMEWHER} when considering entities in the infrastructure that are mobile and would only require the use of a battery.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.9\textwidth]{images/static_power_sources.pdf}
    ~
    \caption{Diagram depicting how static power sources retain their entities as time moves forward in the simulation.}
    \label{fig:staticPower}
\end{figure}

\section{Event Domain}\label{sec:events}
Extended LEAF also introduces easier approaches in allowing actions to occur during the execution of the simulation.
Events see to allow for changes in the model state at predefined periods of time.
Events can be used in two approaches, act as singular atomic actions that occurs at a particular moment during the simulation or can be actions that occur periodically every $\mathbf{k\varDelta t}$.
For instance events may be utilised to manage when applications are ran and terminated in the simulation, or could see to introduce or remove parts of any layer of the model to simulate real life situations such as compute nodes going down.
As discussed in Section \ref{subsec:distributing-entities}, the power domain sees to carry out these actions before carrying out the remaining workflow.
It is assumed that these events occur instantaneously despite these actions in a real life context may not being so.
Figure \ref{fig:events} shows an illustrative example for how a simulation may utilise events to directly alter the state of the simulation to simulate particular scenarios.\\ \\
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{images/events.pdf}
    ~
    \caption{Diagram depicting an illustrative representation of how each layer in the Extended LEAF architecture can be changed.}
    \label{fig:events}
\end{figure}
From what is shown we can see that events are bound to power domains rather than the model as a whole.
The events in power domain 1 show how the power layer of the model can be changed, here we see a battery that is present in power domain 1 being regularly recharged.
The events in power domain 2 depict how the application layer of the model can be changed, here we see the running of an application for $\mathbf{i - 1}$ units of time.
Finally, the event in power domain 3 shows how the infrastructure layer can be changed, here we see how a node n can be introduced to the infrastructure in power domain n.

%==================================================================================================================================
\chapter{Implementation}
%What did you do to implement this idea, and what technical achievements did you make?
%\section{Guidance}
%You can't talk about everything. Cover the high level first, then cover important, relevant or impressive details.
Using the concepts discussed in the previous chapter, the following sections go onto explain how these designs were realised during development to produce the final product.

\section{Python Implentation}\label{sec:python}
At the start of development, the first task required of me was to determine what programming language Extended LEAF was going to use.
As Extended LEAF is a framework and would require users to work in this language to create simulations, the language in question needed to be chosen carefully.
While I was free to determine what language could be used, as the project saw to continue the work made by \cite{leaf2021}, realistically the language would either be Java (\textit{used to prototype early versions of LEAF}) or Python (\textit{the current platform which sees active development}).
Ultimately, the language that was chosen in the end was Python, the reason for this can be seen in why LEAF's transitioned to Python in the first instance: ``the cleaner interface, improved usability, and bigger third party library support \citep{leaf-java-git}''.\\ \\
As Extended LEAF utilises the current implementation of LEAF, a core development philosophy was to ensure that through good programming practises, as discussed by \citep{looseCoupling}, existing simulations and scenarios could be performed on the new model with no requirements to provide any power source or power domains.
When work started on extending LEAF to introduce power sources and carbon awareness, considerations needed to be made on how these interactions could occur without enforcing these dependencies.
As a result, this led to the conceptualisation of the power domain as a mediator to allow for these interactions to occur whilst retaining a loose coupling with the infrastructure class.
Figure \ref{fig:archtecture} shows in reality how the architecture of the model was implemented.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.9\textwidth]{images/Architecture.pdf}
    ~
    \caption{Architecture overview showing interactions between layers.}
    \label{fig:archtecture}
\end{figure}

As we can see, similar to how the orchestrator class mediates the relationships between the application and infrastructure layer, Extended LEAF allows interactions to occur between the power source and infrastructure layer through power domains.

\section{Development Process}\label{sec:development}
To understand how the details on particular aspects of Extended LEAF work, it would be a good idea to explore how the development process initially started.
Upon being informed about LEAF's existence by Thamsen, it was suggested that documentation about the framework was explored.

To get a better understanding of how LEAF fundamentally worked, the examples that existed were explred
-reviewing documentation and reading on how LEAF works
- looking at the basic examples and how a simulation was created
- creating my own and understanding what the core aspects of the system were realised
- moving onto the larger examples
- built power sources to see roughly how power would could be taken supplied
- fast realisation that a mediator would be needed to see that these power sources could run in the simpy environment

\section{Fundamental Aspects}\label{imp:sec:time-data}
To provide context ahead of the discussion about the core aspects of Extended LEAF, the following subsections explain the fundamental concepts the framework uses in order to operate.

\subsection{Discrete Event Simulations}\label{imp:subsec:des}
As briefly mentioned in Section \ref{subsec:power-domain-workflow} LEAF and subsequently Extended LEAF forward time through the use of Discrete Event Simulations (DESs).
DESs simulate environments by changing the state of the model through events, where events are used to describe actions that result in a direct transition from one state to another.
Extended LEAF incorporates this through the use of the Python SimPy package \cite{simpy}.
Looking at Listing \ref{lst:simpy} we can provide an example to show how the SimPy package can create a simulation instance and execute code periodically:
\begin{lstlisting}[language=python, numbers=left, caption={Example use of the SimPy environment}, label=lst:simpy]
    def driver_Method():
        env = simpy.Environment()
        env.process(task(env))
        env.run(until=10)  # Run simulation for 10 units of time

    def task(env):
        while True:
            current_time = env.now()
            print(f"Task has been ran at time increment {current_time}")
            yield env.timeout(2)

    driver_Method()  # Run driver method
\end{lstlisting}
\begin{lstlisting}[language=TeX, caption={Terminal output of Listing \ref{lst:simpy}}, label=lst:simpy-output]
Task has been run at time increment 0
Task has been run at time increment 2
Task has been run at time increment 4
Task has been run at time increment 6
Task has been run at time increment 8
\end{lstlisting}

In this we can see that in the Environment() class is used to declare and initialise the simulation keeping reference through the env variable.
The example then proceeds to inform the model to execute the task method inside the simulation environment by invoking process() with the task method call is passed as a parameter.
Finally the simulation has its terminating condition defined by passing an explicit value for the until argument, signalling the simulation to terminate when the time equals 10.
To allow for the task method to be considered an `event' by the SimPy environment, the task method must be considered a ``Python generator'', where the yield environment.timeout() inside the body of the method to allow for the state of the model to progress forward in time.
In order to allow for the task to be called periodically, the task method encloses the logic of its body inside an indefinite while loop and uses yield environment.timeout(2) to pause the simulation for 2 units of time.
Fundamentally, Extended LEAF uses this approach in order to allow the power domain to execute it's workflow on the most current state of the model during the simulation.

\subsection{Time}\label{imp:subsec:time}
Now that a means to progress time forward within the simulation space has been established, we can now discuss how and why the implementation does this.
As consequence of using historical data mapped to time, \textit{discussed in the upcoming section}, Extended LEAF needs a means to go from an integer based representation of time to one that is formatted as HH\%MM\%SS.
This is achieved by assuming that for every increment of 1 in env.now() a minute passes or 60 seconds passes in real time.
A minute was chosen because the simulation could avoid taking unnecessary measurements of the simulation for small periods of time where the state of the model is unlikely to change, but still capable of capturing changes in the state that would only occur in a relatively short period of time.
However in order to allow for the current state to be uniquely identified in simulations that occur for longer than 24 hours, Extended LEAF identifies each state using the integer representation of time.
This is to ensure that when data is written to file, entries logged by the power domain wont get overwritten due to the fact they are both identified by the same time.

\subsection{Accessing Data}\label{imp:subsec:daa}

As a core requirement of the project was to allow for fluctuations in power availability, Extended LEAF models a power source's power availability and carbon intensity as values that are updated every step forward in time.
When the simulation moves forward in time, a power source will determine its available power and carbon intensity that it should have at that corresponding moment.
For cases where power availability fluctuates (power sources that arent assumed to have a constant rate of power generation), the power source will consult a dictionary of corresponding (time,power) pairings using the current time of the simulation to produce the key to determine its power.
This data is loaded in from file when the class is initialised and provides the data for an entire 24 hours.
As a consequence of the differing rates in how often measurements for power throughput were captured in the original datasets, there exists discrepancies in time granularity for when a power source sees a change in available power.
For instance one data set that fluctuates aggressively may have a reading every minute to capture this property, whereas a power source with a fairly minimal changes in power may only have readings every 30 minutes.
To resolve this, Extended LEAF assumes that between changes in power readings, the power source maintains the previous rate until a new value is able to be retrieved.
This can be seen in Listing \ref{lst:time} which demonstrates how this assumption is implemented.\\

\begin{lstlisting}[language=python, numbers=left, caption={Example use of how a power source accesses it's available power.}, label=lst:time]
    def get_power_at_time(self, time_int) -> float:
        time = self._map_to_time((time_int // self.update_interval) % len(self.power_data))
        return float(self.power_data[time])
\end{lstlisting}

In order to find the appropriate key to determine the power available, the method carries out a floor division between the current time and difference between readings in order to find the most recent time.
To allow for simulations that take longer than 24 hours, the simulation wraps the key value back to the start once it reaches the end, this is done by applying the modulus of the size of the dictionary to this value.
From this, \_map\_to\_time() is used to convert this integer representation of time to a 24 hour string key to obtain the correct power from the dictionary.
To help illustrate this idea, Table \ref{tab:data-dic} visualises what an example dictionary may look like, with Table \ref{tab:time-explanation} describing what the first 10 seconds of the simulation would provide.
\begin{table}[h]
    \rowcolors{2}{}{gray!3}
    \caption{Table depicting the data held in file}
    \label{tab:data-dic}
    \centering
    \begin{tabular}{@{}ccc@{}}
    \toprule
    \textbf{Time} & \textbf{Power} \\
    \midrule
    12:00:00      & 102            \\
    12:05:00      & 114            \\
    12:10:00      & 127            \\
    \bottomrule
    \end{tabular}

    \vspace{1em} % Add some vertical space between the tables
    \rowcolors{2}{}{gray!3}
    \caption{Table depicting how in reality power would be read from a power source's dictionary}
    \label{tab:time-explanation}
    %\tt
    \begin{tabular}{@{}lll@{}}
    \toprule
    \textbf{Env.now()}    & \textbf{Key}       & \textbf{Power}     \\
    \midrule
    0                     & 12:00:00           & 102                \\
    1                     & 12:00:00           & 102                \\
    2                     & 12:00:00           & 102                \\
    3                     & 12:00:00           & 102                \\
    4                     & 12:00:00           & 102                \\
    5                     & 12:05:00           & 114                \\
    6                     & 12:05:00           & 114                \\
    7                     & 12:05:00           & 114                \\
    8                     & 12:05:00           & 114                \\
    9                     & 12:05:00           & 114                \\
    10                    & 12:10:00           & 127                \\
    \bottomrule
    \end{tabular}
\end{table}

\section{Power Domain}\label{sec:power-domain}
The power domain is realised in Extended LEAF through initialising a class instance of PowerDomain.
when PowerDomain is initialized the user is expected to pass through a variety of items
- the simulation variable
- the time (string) when it should start, used to format the data (discussed later on)
- user passes through what entities they want to be dynamically distributed
- the distribution method
- the initial set of power sources
-  user has to provide a name
As the power domains goal is to distribute entities (instances of Infrastructure) it is expected that at least 1 power source is present
Because Extended LEAF allows for external actions to change the state of the simulation, the power domain allows for both power sources and entities to be ammended during runtime, therefore the power domain can invoke these methods to do so

- discuss how the workflow works
\subsection{Powered Infrastructure Distributor}\label{imp:subsec:distributor}
- mention seperate class, discuss params
- the user can define their own
- Extended LEAF has its own default approach
(go through this, attach to appendicies )

\subsection{Logging Results}\label{imp:subsec:logging-results}
- remaining

\section{Power Sources}\label{sec:power-sources}

\subsection{Static Power Sources}\label{imp:subsec:static-power-sources}
When a power source is defined as static, the user must provide the entities from the infrastructure that they want to associate the source to.
From this, the power source will only distribute power to these provided entities and disregard the distribution process of the power domain, if a situation occurs where the power source can no longer provide power to these entities then all nodes and links associated will be powered off and any tasks running will be paused until power can be provided to the entity.
The model provides this ability to allow for scenarios when a simulation requires various power sources but needs to impose restrictions on particular entities in the infrastructure.

\subsection{Dynamic Power Sources}\label{imp:subsec:dynamic-power-sources}
When a power source is defined as dynamic, the user will associate any entities within the infrastructure to the power domain, represented as $\mathbf{I_{pd} \in I}$, where $\mathbf{I}$ encompasses all nodes and links denoted as $\mathbf{\{N\} \cup \{L\}}$.
From this the responsibility to allocate a power source resolves to the power domains distribution method discussed in \ref{subsec:distributing-entities}, whether being the default algorithm provided by Extended LEAF or one defined by the user.
Unlike the statically defined power source configuration, when a scenario occurs where an infrastructure entity is not allocated directly to a power source the simulation fails.\\

\subsection{Power Source Types}\label{imp:subsec:power-source-types}
In order to realise the ability to fluctuate power availability and carbon intensity, Extended LEAF introduces Power Types for power sources.
Power sources should be characterised into groups based on attributes inherent to them.
For instance, an assumption made by Extended LEAF is the idea that real life power sources such as the National Energy Grid in the UK
3 main types:
renewable:
    - static carbon intensity
    - variable power
mixed
    - variable carbon intensity (as a result of combo of non)
    - assumed unlimited power
battery
    - small static carbon intensity
    - finite power
    - power is provided from another source and is recharged by them, providing source emits the carbon obvisouly

The goal of these events is to allow for users to
- core feature to integrate functionality and allow for actions/events to occur without going into the power domain/ runner to alter logic
- events can be repeated
- events are called to alter functionality to represent changing conditions of the simulation, allowing for more complex interactions
- events are executed
- power domain bound
\section{Events}\label{imp:sec:envts}

\section{Running Simulations}\label{imp:sec:running-simulations}

\section{Displaying Results}\label{sec:displaying-results}

++++++++++++++++++++++
TODO: rewrite to move focus on how this would occur i.e. dicuss as mentioned we operate between three layers, in order to facilitate the interactions mediatior
+++++++++++++

At the top layer, the model considers the applications of the simulation which describes the sequential series of tasks and their flow of data from a source task to a sink task.
These applications are then placed on top of the infrastructure layer through a mediation process which identifies the most suitable infrastructure entity to place a task onto.
The infrastructure layer is used to describe the physical compute nodes and network links of the simulation and how these entities are inter-connected.


\section{Displaying results}\label{subsec:displaying-results}


The final aspect introduced into Extended LEAF was the ability to display results.


- events are logged once power has been consumed
- power consumed
- carbon emitted
- carbon intensity

- further logging is made calculating total carbon emitted for the source in total at time t
- Graphs are produced showing how values change over time
- optional class the user can implement
- passes through the power domain per file writer
- specify what graphs they want to plot

In general, Extended LEAF was designed in an manner that would compliment the existing simulation framework but not have a mandated requirement for its features to be incorporated to carry out simulations.
As such, the extension was designed to be loosely coupled to the existing framework \citep{looseCoupling}, therefore allowing for existing simulations and scenarios to be performed under no restrictions to realise any power source or power domain.
The framework achieves this by allowing the power layer to have an unrestricted view of the underlying infrastructure of the model, being able to query the state of entities in the above layer and having the power domain carry out necessary actions on the infrastructure.
In particular, the framework operates within a unified discrete event space allowing for a power domain to run simultaneously, as such we can realise interactions between power sources and infrastructure through keeping associations between the two layers respectively.

Despite entities within the infrastructure having the optional ability to indicate a positional location, power sources do not consider share this property and assumes that a power is able to be supplied
As a result of this, Extended LEAF expects power sources to be defined by the user in the unit of watts.


As previously mentioned, power sources interact with the infrastructure through the power domain and can receive entities through the distribution mechanism employed by it.
The remaining part of this section will proceed to describe why





\subsection{Figures}
\emph{Always} refer to figures included, like Figure \ref{fig:relu}, in the body of the text. Include full, explanatory captions and make sure the figures look good on the page.
You may include multiple figures in one float, as in Figure \ref{fig:synthetic}, using \texttt{subcaption}, which is enabled in the template.



% Figures are important. Use them well.
\begin{figure}
    \centering
    \includegraphics[width=0.5\linewidth]{images/relu.pdf}    

    \caption{In figure captions, explain what the reader is looking at: ``A schematic of the rectifying linear unit, where $a$ is the output amplitude,
    $d$ is a configurable dead-zone, and $Z_j$ is the input signal'', as well as why the reader is looking at this: 
    ``It is notable that there is no activation \emph{at all} below 0, which explains our initial results.'' 
    \textbf{Use vector image formats (.pdf) where possible}. Size figures appropriately, and do not make them over-large or too small to read.
    }

    % use the notation fig:name to cross reference a figure
    \label{fig:relu} 
\end{figure}


\begin{figure}
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{images/synthetic.png}
        \caption{Synthetic image, black on white.}
        \label{fig:syn1}
    \end{subfigure}
    ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc. 
      %(or a blank line to force the subfigure onto a new line)
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{images/synthetic_2.png}
        \caption{Synthetic image, white on black.}
        \label{fig:syn2}
    \end{subfigure}
    ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc. 
    %(or a blank line to force the subfigure onto a new line)    
    \caption{Synthetic test images for edge detection algorithms. \subref{fig:syn1} shows various gray levels that require an adaptive algorithm. \subref{fig:syn2}
    shows more challenging edge detection tests that have crossing lines. Fusing these into full segments typically requires algorithms like the Hough transform.
    This is an example of using subfigures, with \texttt{subref}s in the caption.
    }\label{fig:synthetic}
\end{figure}

\clearpage

\subsection{Equations}

Equations should be typeset correctly and precisely. Make sure you get parenthesis sizing correct, and punctuate equations correctly 
(the comma is important and goes \textit{inside} the equation block). Explain any symbols used clearly if not defined earlier. 

For example, we might define:
\begin{equation}
    \hat{f}(\xi) = \frac{1}{2}\left[ \int_{-\infty}^{\infty} f(x) e^{2\pi i x \xi} \right],
\end{equation}    
where $\hat{f}(\xi)$ is the Fourier transform of the time domain signal $f(x)$.

\subsection{Algorithms}
Algorithms can be set using \texttt{algorithm2e}, as in Algorithm \ref{alg:metropolis}.

% NOTE: line ends are denoted by \; in algorithm2e
\begin{algorithm}
    \DontPrintSemicolon
    \KwData{$f_X(x)$, a probability density function returing the density at $x$.\; $\sigma$ a standard deviation specifying the spread of the proposal distribution.\;
    $x_0$, an initial starting condition.}
    \KwResult{$s=[x_1, x_2, \dots, x_n]$, $n$ samples approximately drawn from a distribution with PDF $f_X(x)$.}
    \Begin{
        $s \longleftarrow []$\;
        $p \longleftarrow f_X(x)$\;
        $i \longleftarrow 0$\;
        \While{$i < n$}
        {
            $x^\prime \longleftarrow \mathcal{N}(x, \sigma^2)$\;
            $p^\prime \longleftarrow f_X(x^\prime)$\;
            $a \longleftarrow \frac{p^\prime}{p}$\;
            $r \longleftarrow U(0,1)$\;
            \If{$r<a$}
            {
                $x \longleftarrow x^\prime$\;
                $p \longleftarrow f_X(x)$\;
                $i \longleftarrow i+1$\;
                append $x$ to $s$\;
            }
        }
    }
    
\caption{The Metropolis-Hastings MCMC algorithm for drawing samples from arbitrary probability distributions, 
specialised for normal proposal distributions $q(x^\prime|x) = \mathcal{N}(x, \sigma^2)$. The symmetry of the normal distribution means the acceptance rule takes the simplified form.}\label{alg:metropolis}
\end{algorithm}

\subsection{Tables}

If you need to include tables, like Table \ref{tab:operators}, use a tool like https://www.tablesgenerator.com/ to generate the table as it is
extremely tedious otherwise. 

\begin{table}[]
    \caption{The standard table of operators in Python, along with their functional equivalents from the \texttt{operator} package. Note that table
    captions go above the table, not below. Do not add additional rules/lines to tables. }\label{tab:operators}
    %\tt 
    \rowcolors{2}{}{gray!3}
    \begin{tabular}{@{}lll@{}}
    %\toprule
    \textbf{Operation}    & \textbf{Syntax}                & \textbf{Function}                            \\ %\midrule % optional rule for header
    Addition              & \texttt{a + b}                          & \texttt{add(a, b)}                                    \\
    Concatenation         & \texttt{seq1 + seq2}                    & \texttt{concat(seq1, seq2)}                           \\
    Containment Test      & \texttt{obj in seq}                     & \texttt{contains(seq, obj)}                           \\
    Division              & \texttt{a / b}                          & \texttt{div(a, b) }  \\
    Division              & \texttt{a / b}                          & \texttt{truediv(a, b) } \\
    Division              & \texttt{a // b}                         & \texttt{floordiv(a, b)}                               \\
    Bitwise And           & \texttt{a \& b}                         & \texttt{and\_(a, b)}                                  \\
    Bitwise Exclusive Or  & \texttt{a \textasciicircum b}           & \texttt{xor(a, b)}                                    \\
    Bitwise Inversion     & \texttt{$\sim$a}                        & \texttt{invert(a)}                                    \\
    Bitwise Or            & \texttt{a | b}                          & \texttt{or\_(a, b)}                                   \\
    Exponentiation        & \texttt{a ** b}                         & \texttt{pow(a, b)}                                    \\
    Identity              & \texttt{a is b}                         & \texttt{is\_(a, b)}                                   \\
    Identity              & \texttt{a is not b}                     & \texttt{is\_not(a, b)}                                \\
    Indexed Assignment    & \texttt{obj{[}k{]} = v}                 & \texttt{setitem(obj, k, v)}                           \\
    Indexed Deletion      & \texttt{del obj{[}k{]}}                 & \texttt{delitem(obj, k)}                              \\
    Indexing              & \texttt{obj{[}k{]}}                     & \texttt{getitem(obj, k)}                              \\
    Left Shift            & \texttt{a \textless{}\textless b}       & \texttt{lshift(a, b)}                                 \\
    Modulo                & \texttt{a \% b}                         & \texttt{mod(a, b)}                                    \\
    Multiplication        & \texttt{a * b}                          & \texttt{mul(a, b)}                                    \\
    Negation (Arithmetic) & \texttt{- a}                            & \texttt{neg(a)}                                       \\
    Negation (Logical)    & \texttt{not a}                          & \texttt{not\_(a)}                                     \\
    Positive              & \texttt{+ a}                            & \texttt{pos(a)}                                       \\
    Right Shift           & \texttt{a \textgreater{}\textgreater b} & \texttt{rshift(a, b)}                                 \\
    Sequence Repetition   & \texttt{seq * i}                        & \texttt{repeat(seq, i)}                               \\
    Slice Assignment      & \texttt{seq{[}i:j{]} = values}          & \texttt{setitem(seq, slice(i, j), values)}            \\
    Slice Deletion        & \texttt{del seq{[}i:j{]}}               & \texttt{delitem(seq, slice(i, j))}                    \\
    Slicing               & \texttt{seq{[}i:j{]}}                   & \texttt{getitem(seq, slice(i, j))}                    \\
    String Formatting     & \texttt{s \% obj}                       & \texttt{mod(s, obj)}                                  \\
    Subtraction           & \texttt{a - b}                          & \texttt{sub(a, b)}                                    \\
    Truth Test            & \texttt{obj}                            & \texttt{truth(obj)}                                   \\
    Ordering              & \texttt{a \textless b}                  & \texttt{lt(a, b)}                                     \\
    Ordering              & \texttt{a \textless{}= b}               & \texttt{le(a, b)}                                     \\
    % \bottomrule
    \end{tabular}
    \end{table}
\subsection{Code}

Avoid putting large blocks of code in the report (more than a page in one block, for example). Use syntax highlighting if possible, as in Listing \ref{lst:callahan}.

\begin{lstlisting}[language=python, float, caption={The algorithm for packing the $3\times 3$ outer-totalistic binary CA successor rule into a 
    $16\times 16\times 16\times 16$ 4 bit lookup table, running an equivalent, notionally 16-state $2\times 2$ CA.}, label=lst:callahan]
    def create_callahan_table(rule="b3s23"):
        """Generate the lookup table for the cells."""        
        s_table = np.zeros((16, 16, 16, 16), dtype=np.uint8)
        birth, survive = parse_rule(rule)

        # generate all 16 bit strings
        for iv in range(65536):
            bv = [(iv >> z) & 1 for z in range(16)]
            a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p = bv

            # compute next state of the inner 2x2
            nw = apply_rule(f, a, b, c, e, g, i, j, k)
            ne = apply_rule(g, b, c, d, f, h, j, k, l)
            sw = apply_rule(j, e, f, g, i, k, m, n, o)
            se = apply_rule(k, f, g, h, j, l, n, o, p)

            # compute the index of this 4x4
            nw_code = a | (b << 1) | (e << 2) | (f << 3)
            ne_code = c | (d << 1) | (g << 2) | (h << 3)
            sw_code = i | (j << 1) | (m << 2) | (n << 3)
            se_code = k | (l << 1) | (o << 2) | (p << 3)

            # compute the state for the 2x2
            next_code = nw | (ne << 1) | (sw << 2) | (se << 3)

            # get the 4x4 index, and write into the table
            s_table[nw_code, ne_code, sw_code, se_code] = next_code

        return s_table

\end{lstlisting}

%==================================================================================================================================
\chapter{Evaluation} \label{chp:evaluation}
How good is your solution? How well did you solve the general problem, and what evidence do you have to support that?

When the user sets out to carry out a simulation, the user should reference Figure \ref{fig:archtecture} and work from the bottom up
\section{Introduction}\label{sec:eval-intro}
\section{Introduction}\label{sec:eval-example1}
\section{Introduction}\label{sec:eval-example2}
\section{Introduction}\label{sec:eval-example3}
\section{Introduction}\label{sec:eval-example4}
\section{Introduction}\label{sec:eval-example5}
\section{Introduction}\label{sec:eval-example6}
\section{Introduction}\label{sec:eval-example7}

\section{Guidance}
\begin{itemize}
    \item
        Ask specific questions that address the general problem.
    \item
        Answer them with precise evidence (graphs, numbers, statistical
        analysis, qualitative analysis).
    \item
        Be fair and be scientific.
    \item
        The key thing is to show that you know how to evaluate your work, not
        that your work is the most amazing product ever.
\end{itemize}

\section{Evidence}
Make sure you present your evidence well. Use appropriate visualisations, reporting techniques and statistical analysis, as appropriate.

If you visualise, follow the basic rules, as illustrated in Figure \ref{fig:boxplot}:
\begin{itemize}
\item Label everything correctly (axis, title, units).
\item Caption thoroughly.
\item Reference in text.
\item \textbf{Include appropriate display of uncertainty (e.g. error bars, Box plot)}
\item Minimize clutter.
\end{itemize}

See the file \texttt{guide\_to\_visualising.pdf} for further information and guidance.

\begin{figure}
    \centering
    \includegraphics[width=1.0\linewidth]{images/boxplot_finger_distance.pdf}    

    \caption{Average number of fingers detected by the touch sensor at different heights above the surface, averaged over all gestures. Dashed lines indicate
    the true number of fingers present. The Box plots include bootstrapped uncertainty notches for the median. It is clear that the device is biased toward 
    undercounting fingers, particularly at higher $z$ distances.
    }

    % use the notation fig:name to cross reference a figure
    \label{fig:boxplot} 
\end{figure}


%==================================================================================================================================
\chapter{Conclusion}    
Summarise the whole project for a lazy reader who didn't read the rest (e.g. a prize-awarding committee).
\section{Guidance}
\begin{itemize}
    \item
        Summarise briefly and fairly.
    \item
        You should be addressing the general problem you introduced in the
        Introduction.        
    \item
        Include summary of concrete results (``the new compiler ran 2x
        faster'')
    \item
        Indicate what future work could be done, but remember: \textbf{you
        won't get credit for things you haven't done}.
\end{itemize}
- mention future intrest and collaborations with other students
- mention to incorperate an automatic priorising system to allow for dynamic carbon intensity sources like Grid to have their priority change
- mention that possiblity to introduce priority of nodes/tasks (either or) as currently the model does not preference particular tasks when determining where/ when they are associated to a power source
%==================================================================================================================================
%
% 
%==================================================================================================================================
%  APPENDICES  

\begin{appendices}

\chapter{Appendices}

Typical inclusions in the appendices are:

\begin{itemize}
\item
  Copies of ethics approvals (required if obtained)
\item
  Copies of questionnaires etc. used to gather data from subjects.
\item
  Extensive tables or figures that are too bulky to fit in the main body of
  the report, particularly ones that are repetitive and summarised in the body.

\item Outline of the source code (e.g. directory structure), or other architecture documentation like class diagrams.

\item User manuals, and any guides to starting/running the software.

\end{itemize}

\textbf{Don't include your source code in the appendices}. It will be
submitted separately.

\end{appendices}

%==================================================================================================================================
%   BIBLIOGRAPHY   

% The bibliography style is abbrvnat
% The bibliography always appears last, after the appendices.

\bibliographystyle{abbrvnat}

\bibliography{l4proj}

\end{document}
